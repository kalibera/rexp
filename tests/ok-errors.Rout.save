
R Under development (unstable) (2015-12-07 r69744) -- "Unsuffered Consequences"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #### STRICT test suite in the spirit of no-segfaults,
> #### but with explicit statements.
> 
> options(error=expression(NULL))
> stop("test of `options(error=expression(NULL))'")
Error: test of `options(error=expression(NULL))'
> 
> if(FALSE) {
+ ## these ought to work on machines with enough memory
+ ## These segfaulted in 1.3.x ,  give "could not allocate" errors now
+   integer(2^30+1)
+    double(2^30+1)
+   complex(2^30+1)
+ character(2^30+1)
+ vector("list", 2^30+2)
+ }
> 
> ## bad infinite recursion / on.exit / ... interactions
> ##   catch the error to permit different error texts and different
> ##   number of the error messages emitted (handling of infinite
> ##   recursion is different in AST interpretter and byte-code
> ##   interpretter/compiler
> 
> { g <- function() 1+1 ; f <- function() { on.exit(g()) ; f() } ; tryCatch(f(), error=function(x) TRUE) }
[1] TRUE
> 
> { f <- function() { f() } ; tryCatch(f(), error=function(x) TRUE) }
[1] TRUE
> { f <- function() { on.exit(f()) } ; tryCatch(f(), error=function(x) TRUE) }
[1] TRUE
> { f <- function() { on.exit(f()) ; f() } ; tryCatch(f(), error=function(x) TRUE) }
[1] TRUE
> 
> { f <- function() f() ; tryCatch(tryCatch(f(), finally=f()), error=function(x) TRUE) }
[1] TRUE
> { f <- function() f() ; tryCatch(tryCatch(f(), error=f()), error=function(x) TRUE) }
[1] TRUE
> { f <- function() f() ; tryCatch(tryCatch(f(), error=f(), finally=f()), error=function(x) TRUE) }
[1] TRUE
> { f <- function() tryCatch(f(), error=f(), finally=f()) ; tryCatch(f(), error=function(x) TRUE) }
[1] TRUE
> 
